<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Phép màu</title>
    <link rel="icon" type="image/png" href="./icon.png">
    <style>
        @font-face {
            font-family: 'TF-Love-House';
            src: url('./TF-Love-House.otf') format('opentype');
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none; /* Prevent default touch behaviors */
        }
        #info-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 77, 77, 0.8), rgba(255, 255, 255, 0.3));
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'TF-Love-House', sans-serif;
            z-index: 1000;
        }
        #info-screen h1 {
            font-size: 2.5em;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        #info-screen p {
            font-size: 1.2em;
            margin: 8px;
            text-shadow: 0 0 5px rgba(255, 77, 77, 0.8);
        }
        #start-button {
            padding: 10px 20px;
            font-size: 1.2em;
            background: #ff4d4d;
            color: white;
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.7);
            font-family: 'TF-Love-House', sans-serif;
        }
        #start-button:hover {
            background: #ff4040;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
        }
        canvas {
            display: block;
            touch-action: none;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        #start-button {
            animation: pulse 3s infinite;
        }
        #image-container {
            display: none;
        }
        #image-container img {
            width: 300px;
            height: 300px;
            max-width: 300px;
            max-height: 300px;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.5);
        }
    </style>
</head>
<body>
    <div id="info-screen">
        <h1>Phép màu 1/6</h1>
        <p><strong>Máy tính:</strong></p>
        <p>Chuột: Xoay góc nhìn</p>
        <p>W/A/S/D: Di chuyển</p>
        <p>Space: Bay lên</p>
        <p>Shift: Bay xuống</p>
        <p>Ctrl: Tăng tốc độ</p>
        <p>ESC: Thoát</p>
        <p><strong>Điện thoại:</strong></p>
        <p>Xoay điện thoại: Quan sát 360 độ</p>
        <p>Vuốt 1 ngón: Xoay góc nhìn</p>
        <p>Zoom 2 ngón: Tiến/lùi</p>
        <button id="start-button">Click</button>
    </div>
    <div id="image-container">
        <img src="./anh (1).jpg" alt="Image 1">
        <img src="./anh (2).jpg" alt="Image 2">
        <img src="./anh (3).jpg" alt="Image 3">
        <img src="./anh (4).jpg" alt="Image 4">
        <img src="./anh (5).jpg" alt="Image 5">
        <img src="./anh (6).jpg" alt="Image 6">
        <img src="./anh (7).jpg" alt="Image 7">
        <img src="./anh (8).jpg" alt="Image 8">
        <img src="./anh (9).jpg" alt="Image 9">
        <img src="./anh (10).jpg" alt="Image 10">
        <img src="./anh (11).jpg" alt="Image 11">
        <img src="./anh (12).jpg" alt="Image 12">
        <img src="./anh (13).jpg" alt="Image 13">
        <img src="./anh (14).jpg" alt="Image 14">
        <img src="./anh (15).jpg" alt="Image 15">
        <img src="./anh (16).jpg" alt="Image 16">
        <img src="./anh (17).jpg" alt="Image 17">
        <img src="./anh (18).jpg" alt="Image 18">
        <img src="./anh (19).jpg" alt="Image 19">
        <img src="./anh (20).jpg" alt="Image 20">
        <img src="./anh (21).jpg" alt="Image 21">
        <img src="./anh (22).jpg" alt="Image 22">
        <img src="./anh (23).jpg" alt="Image 23">
        <img src="./anh (24).jpg" alt="Image 24">
        <img src="./anh (25).jpg" alt="Image 25">
        <img src="./anh (26).jpg" alt="Image 26">
        <img src="./anh (27).jpg" alt="Image 27">
        <img src="./anh (28).jpg" alt="Image 28">
        <img src="./anh (29).jpg" alt="Image 29">
        <img src="./anh (30).jpg" alt="Image 30">
        <img src="./anh (31).jpg" alt="Image 31">
        <img src="./anh (32).jpg" alt="Image 32">
        <img src="./anh (33).jpg" alt="Image 33">
        <img src="./anh (34).jpg" alt="Image 34">
        <img src="./anh (35).jpg" alt="Image 35">
        <img src="./anh (36).jpg" alt="Image 36">
    </div>
    <audio id="background-music" autoplay loop>
        <source src="./phepmau.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.23.2/build/postprocessing.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script>
        let scene, camera, renderer, cssRenderer, controls, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let isCtrlPressed = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let particles = [];
        let texts = [];
        let dustParticles = [];
        let imagePlanes = [];
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let touchStartX, touchStartY, pinchStartDistance;
        let isPinching = false, isDragging = false;
        let useGyroscope = false;
        let initialOrientation = null;
        let lastParticleTime = 0;
        const romanticWords = ['I', 'Love', 'You', '<3', 'I', 'Love', 'You', '<3'];
        let font = null;
        let titleFont = null;
        const maxParticles = 200;
        const maxTexts = 200;
        const maxDustGroups = 150;
        const maxImages = 36;
        let availableImages = [];
        const initialLoadTime = performance.now();
        let dynamicLight;
        const maxDistance = 1000;
        const clearZone = 50;
        const blurStartDistance = 150;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.sortObjects = true;
            document.body.appendChild(renderer.domElement);

            cssRenderer = new THREE.CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.domElement.style.position = 'absolute';
            cssRenderer.domElement.style.top = '0';
            document.body.appendChild(cssRenderer.domElement);

            composer = new POSTPROCESSING.EffectComposer(renderer);
            composer.addPass(new POSTPROCESSING.RenderPass(scene, camera));
            const dofEffect = new POSTPROCESSING.DepthOfFieldEffect(camera, {
                focalLength: 0.4,
                bokehScale: 1.5,
                height: window.innerHeight,
                focalDistance: 0.7
            });
            const bloomEffect = new POSTPROCESSING.BloomEffect({
                intensity: 3.5,
                luminanceThreshold: 0.3,
                luminanceSmoothing: 0.1
            });
            const effectPass = new POSTPROCESSING.EffectPass(camera, dofEffect, bloomEffect);
            composer.addPass(effectPass);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);

            dynamicLight = new THREE.PointLight(0xff6666, 2.5, 100, 2);
            dynamicLight.position.set(10, 10, 10);
            scene.add(dynamicLight);

            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            controls.enabled = false;

            controls.addEventListener('unlock', () => {
                document.getElementById('info-screen').style.display = 'flex';
                controls.enabled = false;
            });

            availableImages = Array.from(document.querySelectorAll('#image-container img'));
            if (availableImages.length === 0) {
                console.error('No images found in #image-container');
            } else {
                console.log(`Found ${availableImages.length} images in HTML`);
                preloadImages();
            }

            const loader = new THREE.FontLoader();

            function createMainTexts() {
                const mainTexts = ['I', 'LOVE', 'YOU'];
                mainTexts.forEach((text, index) => {
                    const geometry = new THREE.TextGeometry(text, {
                        font: titleFont,
                        size: 6.4,
                        height: 0.32,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.176,
                        bevelSize: 0.132,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    const material = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                        transparent: true
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        camera.position.x + (Math.random() - 0.5) * 500,
                        camera.position.y + (Math.random() - 0.5) * 500,
                        camera.position.z + (Math.random() - 0.5) * 500
                    );
                    mesh.userData = { 
                        pulse: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02)
                    };
                    scene.add(mesh);
                    texts.push(mesh);
                });
            }

            loader.load('./KD-Yon-Love.ttf', function (loadedFont) {
                titleFont = loadedFont;
                createMainTexts();
                console.log('Loaded KD-Yon-Love.ttf successfully');
            }, undefined, function (error) {
                console.error('Error loading KD-Yon-Love.ttf:', error);
                loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (loadedFont) {
                    titleFont = loadedFont;
                    createMainTexts();
                    console.log('Loaded fallback font helvetiker_bold');
                });
            });

            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function (loadedFont) {
                font = loadedFont;
                console.log('Loaded helvetiker_bold for text spawning');
            });

            const particleGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            for (let i = 0; i < 50; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, material);
                particle.position.set(
                    camera.position.x + (Math.random() - 0.5) * 500,
                    camera.position.y + (Math.random() - 0.5) * 500,
                    camera.position.z + (Math.random() - 0.5) * 500
                );
                particle.userData = { 
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02),
                    pulse: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };
                scene.add(particle);
                particles.push(particle);
            }

            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 800;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.4,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.2,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -0.03,
                    (Math.random() - 0.5) * 0.01
                ))
            };
            dustParticles.push(dust);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('start-button').addEventListener('click', startExperience);

            if (isMobile) {
                setupGyroscope();
                renderer.domElement.addEventListener('touchstart', onTouchStart);
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd);
                // Prevent default pinch-to-zoom
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                document.addEventListener('gesturechange', (e) => e.preventDefault());
                document.addEventListener('gestureend', (e) => e.preventDefault());
            }

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function setupGyroscope() {
            if (window.DeviceOrientationEvent) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', onDeviceOrientation);
                                useGyroscope = true;
                                console.log('Gyroscope permission granted');
                            } else {
                                console.log('Gyroscope permission denied, falling back to touch rotation');
                            }
                        })
                        .catch(error => console.error('Error requesting gyroscope permission:', error));
                } else {
                    window.addEventListener('deviceorientation', onDeviceOrientation);
                    useGyroscope = true;
                    console.log('Gyroscope enabled without permission');
                }
            } else {
                console.log('DeviceOrientation API not supported, falling back to touch rotation');
            }
        }

        function onDeviceOrientation(event) {
            if (!initialOrientation) {
                initialOrientation = { alpha: event.alpha, beta: event.beta, gamma: event.gamma };
                return;
            }

            // Convert angles to radians
            let alpha = THREE.MathUtils.degToRad(event.alpha || 0); // Yaw
            let beta = THREE.MathUtils.degToRad(event.beta || 0);   // Pitch
            let gamma = THREE.MathUtils.degToRad(event.gamma || 0); // Roll

            // Adjust for initial orientation
            alpha -= THREE.MathUtils.degToRad(initialOrientation.alpha || 0);
            beta -= THREE.MathUtils.degToRad(initialOrientation.beta || 0);
            gamma -= THREE.MathUtils.degToRad(initialOrientation.gamma || 0);

            // Detect device orientation
            const isLandscape = Math.abs(window.orientation) === 90;
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

            // Create quaternion
            const quaternion = new THREE.Quaternion();
            const euler = new THREE.Euler();

            // Apply rotations
            if (isIOS) {
                euler.set(beta, -alpha, gamma, 'YXZ');
            } else {
                euler.set(beta, alpha, -gamma, 'YXZ');
            }

            // Adjust for landscape
            if (isLandscape) {
                const landscapeAdjust = new THREE.Euler(0, 0, Math.PI / 2);
                const landscapeQuat = new THREE.Quaternion().setFromEuler(landscapeAdjust);
                quaternion.multiply(landscapeQuat);
            }

            // Convert Euler to Quaternion
            quaternion.setFromEuler(euler);

            // Apply to camera if not dragging
            if (!isDragging) {
                camera.quaternion.copy(quaternion);
            }

            // Limit pitch
            const eulerCheck = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            eulerCheck.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, eulerCheck.x));
            camera.quaternion.setFromEuler(eulerCheck);

            // Debug
            console.log(`Alpha: ${THREE.MathUtils.radToDeg(alpha)}, Beta: ${THREE.MathUtils.radToDeg(beta)}, Gamma: ${THREE.MathUtils.radToDeg(gamma)}`);
        }

        function preloadImages() {
            availableImages.forEach(img => {
                const tempImage = new Image();
                tempImage.src = img.src;
                tempImage.onload = () => console.log(`Preloaded image: ${img.src}`);
                tempImage.onerror = () => console.error(`Failed to preload image: ${img.src}`);
            });
        }

        function startExperience() {
            document.getElementById('info-screen').style.display = 'none';
            controls.enabled = true;
            if (!isMobile) {
                controls.lock();
            }
            const audio = document.getElementById('background-music');
            if (audio.paused) {
                audio.play().catch(error => console.error('Error playing audio:', error));
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': moveUp = true; break;
                case 'Space': moveDown = true; break;
                case 'ControlLeft':
                case 'ControlRight': isCtrlPressed = true; break;
                case 'Escape': controls.unlock(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': moveUp = false; break;
                case 'Space': moveDown = false; break;
                case 'ControlLeft':
                case 'ControlRight': isCtrlPressed = false; break;
            }
        }

        function onTouchStart(event) {
            console.log('Touch start:', event.touches.length);
            event.preventDefault();
            if (event.touches.length === 1) {
                // Single finger drag
                isDragging = true;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                // Two fingers pinch
                isPinching = true;
                isDragging = false;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            event.stopPropagation();
            console.log('Touch move:', event.touches.length, 'Scale:', event.scale);
            if (event.touches.length === 1 && isDragging) {
                // Single finger drag
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                camera.rotation.order = 'YXZ';
                camera.rotation.y -= deltaX * 0.005;
                camera.rotation.x -= deltaY * 0.005;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2 && isPinching) {
                // Two fingers pinch
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const deltaPinch = (distance - pinchStartDistance) * 0.1; // Normalize sensitivity
                const moveSpeed = 0.2; // Adjusted for smoother movement
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                camera.position.add(forward.multiplyScalar(deltaPinch * moveSpeed));
                pinchStartDistance = distance;
            }
        }

        function onTouchEnd(event) {
            console.log('Touch end');
            event.preventDefault();
            isPinching = false;
            isDragging = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function spawnTextNearCamera() {
            if (!font || texts.length >= maxTexts) return;
            const text = romanticWords[Math.floor(Math.random() * romanticWords.length)];
            const geometry = new THREE.TextGeometry(text, {
                font: font,
                size: 4.0,
                height: 0.528,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.132,
                bevelSize: 0.099,
                bevelOffset: 0,
                bevelSegments: 3
            });
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                camera.position.x + (Math.random() - 0.5) * 350,
                camera.position.y + (Math.random() - 0.5) * 350,
                camera.position.z + (Math.random() - 0.5) * 350
            );
            mesh.userData = { 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(mesh);
            texts.push(mesh);
        }

        function spawnParticleAtCamera() {
            if (particles.length >= maxParticles) return;
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const particle = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), material);
            const radius = 100;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            particle.position.copy(camera.position);
            particle.position.add(new THREE.Vector3(x, y, z));
            particle.userData = { 
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02, (Math.random() - 0.5) * 0.02),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(particle);
            particles.push(particle);
        }

        function spawnDustNearCamera() {
            if (dustParticles.length >= maxDustGroups) return;
            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 800;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.4,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.2,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    -0.03,
                    (Math.random() - 0.5) * 0.01
                ))
            };
            dustParticles.push(dust);
        }

        function spawnImageNearCamera() {
            if (imagePlanes.length >= maxImages || availableImages.length === 0) {
                console.log(`Cannot spawn image: max images reached (${imagePlanes.length}/${maxImages}) or no available images`);
                return;
            }
            const imgElement = availableImages[Math.floor(Math.random() * availableImages.length)];
            const cssObject = new THREE.CSS3DObject(imgElement.cloneNode(true));
            const minDistance = 50;
            const maxDistance = 200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const radius = minDistance + Math.random() * (maxDistance - minDistance);
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            cssObject.position.copy(camera.position);
            cssObject.position.add(new THREE.Vector3(x, y, z));
            cssObject.lookAt(camera.position);
            const scaleFactor = 0.05;
            cssObject.scale.set(scaleFactor, scaleFactor, scaleFactor);
            cssObject.userData = {
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.01, 0.01, (Math.random() - 0.5) * 0.01),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.005
            };
            scene.add(cssObject);
            imagePlanes.push(cssObject);
            console.log(`Spawned CSS3D image at position: ${cssObject.position.x}, ${cssObject.position.y}, ${cssObject.position.z}`);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            dynamicLight.position.set(
                10 * Math.sin(time * 0.001),
                10 * Math.cos(time * 0.001),
                10 * Math.sin(time * 0.0005)
            );
            dynamicLight.intensity = 2.5 + Math.sin(time * 0.002) * 0.5;

            const isInitialLoad = time < initialLoadTime + 5000;
            const textSpawnChance = isInitialLoad ? 0.5 : 0.2;
            const dustSpawnChance = isInitialLoad ? 0.9 : 0.5;
            const imageSpawnChance = isInitialLoad ? 0.03 : 0.01;

            let textCount = 0;
            if (Math.random() < textSpawnChance && texts.length < maxTexts && textCount < 5) {
                spawnTextNearCamera();
                textCount++;
            }

            let particleCount = 0;
            if (((moveForward || moveBackward || moveLeft || moveRight || moveUp || moveDown) && time - lastParticleTime > 10) || Math.random() < 0.25) {
                if (particles.length < maxParticles && particleCount < 5) {
                    spawnParticleAtCamera();
                    lastParticleTime = time;
                    particleCount++;
                }
            }

            if (Math.random() < dustSpawnChance && dustParticles.length < maxDustGroups) {
                spawnDustNearCamera();
            }

            let imageCount = 0;
            if (Math.random() < imageSpawnChance && imagePlanes.length < maxImages && imageCount < 2) {
                spawnImageNearCamera();
                imageCount++;
            }

            particles.forEach(particle => {
                particle.position.add(particle.userData.velocity);
                particle.rotation.x += particle.userData.rotationSpeed;
                particle.rotation.y += particle.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + particle.userData.pulse) * 0.2 + 0.8;
                const distance = particle.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 100));
                particle.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || particle.position.y < camera.position.y - maxDistance) {
                    scene.remove(particle);
                    particles = particles.filter(p => p !== particle);
                }
            });

            texts.forEach(text => {
                text.position.add(text.userData.velocity);
                text.rotation.y += text.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + text.userData.pulse) * 0.2 + 0.8;
                const distance = text.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 100));
                text.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || text.position.y < camera.position.y - maxDistance) {
                    scene.remove(text);
                    texts = texts.filter(t => t !== text);
                }
            });

            dustParticles = dustParticles.filter(dust => {
                const positions = dust.geometry.attributes.position.array;
                const velocities = dust.userData.velocities;
                let keep = false;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i / 3].x;
                    positions[i + 1] += velocities[i / 3].y;
                    positions[i + 2] += velocities[i / 3].z;
                    const distance = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]).distanceTo(camera.position);
                    if (distance <= maxDistance && positions[i + 1] > camera.position.y - maxDistance) {
                        keep = true;
                        const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.1, Math.exp(-(distance - clearZone) / 100));
                        dust.material.opacity = 1.2 * fadeFactor;
                    }
                }
                dust.geometry.attributes.position.needsUpdate = true;
                dust.material.needsUpdate = true;
                if (!keep) {
                    scene.remove(dust);
                    return false;
                }
                return true;
            });

            imagePlanes.forEach(image => {
                image.position.add(image.userData.velocity);
                image.lookAt(camera.position);
                image.rotation.y += image.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + image.userData.pulse) * 0.1 + 0.9;
                const distance = image.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1.0 : Math.max(0.5, Math.exp(-(distance - clearZone) / 50));
                image.element.style.opacity = pulse * fadeFactor;
                if (distance > maxDistance || image.position.y > camera.position.y + maxDistance) {
                    console.log(`Removing CSS3D image at position: ${image.position.x}, ${image.position.y}, ${image.position.z}`);
                    scene.remove(image);
                    imagePlanes = imagePlanes.filter(img => img !== image);
                }
            });

            if (!isMobile) {
                velocity.x *= 0.9;
                velocity.y *= 0.9;
                velocity.z *= 0.9;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
                if (moveUp || moveDown) velocity.y -= direction.y * 400.0 * delta;

                const speedMultiplier = isCtrlPressed ? 2.0 : 1.0;
                controls.moveRight(-velocity.x * delta * speedMultiplier);
                controls.moveForward(-velocity.z * delta * speedMultiplier);
                controls.getObject().position.y += velocity.y * delta * speedMultiplier;
            }

            composer.render();
            cssRenderer.render(scene, camera);
            prevTime = time;
        }

        init();
    </script>
</body>
</html>
