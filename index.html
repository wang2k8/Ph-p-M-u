<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Phép Màu 1/6</title>
    <link rel="icon" type="image/png" href="./icon.png">
    <style>
        @font-face {
            font-family: 'TF-Love-House';
            src: url('./TF-Love-House.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #info-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255, 77, 77, 0.9), rgba(255, 255, 255, 0.4));
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'TF-Love-House', sans-serif;
            z-index: 1000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        #info-screen h1 {
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 5px rgba(255, 77, 77, 0.8);
        }
        #info-screen p {
            font-size: 1.3em;
            margin: 10px 20px;
            text-shadow: 0 0 8px rgba(255, 77, 77, 0.7);
        }
        #start-button {
            padding: 15px 30px;
            font-size: 1.5em;
            background: linear-gradient(45deg, #ff4d4d, #ff7878);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.8), 0 0 10px rgba(255, 255, 255, 0.5);
            font-family: 'TF-Love-House', sans-serif;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        #start-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 77, 77, 1), 0 0 15px rgba(255, 255, 255, 0.8);
        }
        canvas {
            display: block;
            touch-action: none;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
        #start-button {
            animation: pulse 2.5s infinite ease-in-out;
        }
        #image-container {
            display: none;
        }
        #image-container img {
            width: 300px;
            height: 300px;
            max-width: 300px;
            max-height: 300px;
            object-fit: cover;
            border-radius: 15px;
            box-shadow: 0 0 15px rgba(255, 77, 77, 0.6);
        }
    </style>
</head>
<body>
    <div id="info-screen">
        <h1>Phép Màu 1/6</h1>
        <p><strong>Máy tính:</strong></p>
        <p>Chuột: Xoay góc nhìn</p>
        <p>W/A/S/D: Di chuyển</p>
        <p>Space: Bay lên</p>
        <p>Shift: Bay xuống</p>
        <p>Ctrl: Tăng tốc</p>
        <p>ESC: Thoát</p>
        <p><strong>Điện thoại:</strong></p>
        <p>Xoay điện thoại: Quan sát 360°</p>
        <p>Vuốt 1 ngón: Xoay góc nhìn</p>
        <p>Zoom 2 ngón: Tiến/lùi</p>
        <button id="start-button">Bắt đầu</button>
    </div>
    <div id="image-container">
        <img src="./anh (1).jpg" alt="Image 1">
        <img src="./anh (2).jpg" alt="Image 2">
        <img src="./anh (3).jpg" alt="Image 3">
        <img src="./anh (4).jpg" alt="Image 4">
        <img src="./anh (5).jpg" alt="Image 5">
        <img src="./anh (6).jpg" alt="Image 6">
        <img src="./anh (7).jpg" alt="Image 7">
        <img src="./anh (8).jpg" alt="Image 8">
        <img src="./anh (9).jpg" alt="Image 9">
        <img src="./anh (10).jpg" alt="Image 10">
        <img src="./anh (11).jpg" alt="Image 11">
        <img src="./anh (12).jpg" alt="Image 12">
        <img src="./anh (13).jpg" alt="Image 13">
        <img src="./anh (14).jpg" alt="Image 14">
        <img src="./anh (15).jpg" alt="Image 15">
        <img src="./anh (16).jpg" alt="Image 16">
        <img src="./anh (17).jpg" alt="Image 17">
        <img src="./anh (18).jpg" alt="Image 18">
        <img src="./anh (19).jpg" alt="Image 19">
        <img src="./anh (20).jpg" alt="Image 20">
        <img src="./anh (21).jpg" alt="Image 21">
        <img src="./anh (22).jpg" alt="Image 22">
        <img src="./anh (23).jpg" alt="Image 23">
        <img src="./anh (24).jpg" alt="Image 24">
        <img src="./anh (25).jpg" alt="Image 25">
        <img src="./anh (26).jpg" alt="Image 26">
        <img src="./anh (27).jpg" alt="Image 27">
        <img src="./anh (28).jpg" alt="Image 28">
        <img src="./anh (29).jpg" alt="Image 29">
        <img src="./anh (30).jpg" alt="Image 30">
        <img src="./anh (31).jpg" alt="Image 31">
        <img src="./anh (32).jpg" alt="Image 32">
        <img src="./anh (33).jpg" alt="Image 33">
        <img src="./anh (34).jpg" alt="Image 34">
        <img src="./anh (35).jpg" alt="Image 35">
        <img src="./anh (36).jpg" alt="Image 36">
    </div>
    <audio id="background-music" autoplay loop>
        <source src="./phepmau.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/TextGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/postprocessing@6.23.2/build/postprocessing.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script>
        // Core variables
        let scene, camera, renderer, cssRenderer, controls, composer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let isCtrlPressed = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        let particles = [], texts = [], dustParticles = [], imagePlanes = [];
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let touchStartX, touchStartY, pinchStartDistance;
        let isPinching = false, isDragging = false;
        let useGyroscope = false, initialOrientation = null;
        let lastParticleTime = 0;
        let isExperienceStarted = false; // Track if experience has started
        const romanticWords = ['I', 'Love', 'You', '<3', 'I', 'Love', 'You', '<3'];
        let font = null, titleFont = null;
        const maxParticles = 150, maxTexts = 150, maxDustGroups = 100, maxImages = 36;
        let availableImages = [];
        const initialLoadTime = performance.now();
        let dynamicLight;
        const maxDistance = 1000, clearZone = 50;

        // Initialize the scene
        function init() {
            // Setup scene and camera
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 10);

            // Setup WebGL renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // Setup CSS3D renderer for images
            cssRenderer = new THREE.CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.domElement.style.position = 'absolute';
            cssRenderer.domElement.style.top = '0';
            document.body.appendChild(cssRenderer.domElement);

            // Setup post-processing effects
            composer = new POSTPROCESSING.EffectComposer(renderer);
            composer.addPass(new POSTPROCESSING.RenderPass(scene, camera));
            const dofEffect = new POSTPROCESSING.DepthOfFieldEffect(camera, {
                focalLength: 0.4,
                bokehScale: 2.0,
                height: window.innerHeight,
                focalDistance: 0.7
            });
            const bloomEffect = new POSTPROCESSING.BloomEffect({
                intensity: 4.0,
                luminanceThreshold: 0.3,
                luminanceSmoothing: 0.1
            });
            const effectPass = new POSTPROCESSING.EffectPass(camera, dofEffect, bloomEffect);
            composer.addPass(effectPass);

            // Add lighting
            scene.add(new THREE.AmbientLight(0x404040, 0.9));
            dynamicLight = new THREE.PointLight(0xff6666, 3.0, 100, 2);
            dynamicLight.position.set(10, 10, 10);
            scene.add(dynamicLight);

            // Setup controls
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            controls.enabled = false;
            controls.addEventListener('unlock', () => {
                document.getElementById('info-screen').style.display = 'flex';
                controls.enabled = false;
                isExperienceStarted = false;
            });

            // Load images
            availableImages = Array.from(document.querySelectorAll('#image-container img'));
            if (availableImages.length === 0) console.error('No images found');
            else preloadImages();

            // Load fonts
            const loader = new THREE.FontLoader();
            function createMainTexts() {
                ['I', 'LOVE', 'YOU'].forEach((text, index) => {
                    const geometry = new THREE.TextGeometry(text, {
                        font: titleFont,
                        size: 7,
                        height: 0.4,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.2,
                        bevelSize: 0.15,
                        bevelSegments: 5
                    });
                    const material = new THREE.MeshBasicMaterial({
                        color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                        transparent: true
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(
                        camera.position.x + (Math.random() - 0.5) * 500,
                        camera.position.y + (Math.random() - 0.5) * 500,
                        camera.position.z + (Math.random() - 0.5) * 500
                    );
                    mesh.userData = {
                        pulse: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.02,
                        velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, -0.05, (Math.random() - 0.5) * 0.02)
                    };
                    scene.add(mesh);
                    texts.push(mesh);
                });
            }

            loader.load('./KD-Yon-Love.ttf', (loadedFont) => {
                titleFont = loadedFont;
                createMainTexts();
                console.log('Loaded KD-Yon-Love.ttf');
            }, undefined, (error) => {
                console.error('Error loading KD-Yon-Love.ttf:', error);
                loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (loadedFont) => {
                    titleFont = loadedFont;
                    createMainTexts();
                    console.log('Loaded fallback font helvetiker_bold');
                });
            });

            loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (loadedFont) => {
                font = loadedFont;
                console.log('Loaded helvetiker_bold for text spawning');
            });

            // Create initial particles
            const particleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            for (let i = 0; i < 50; i++) {
                const material = new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                    transparent: true,
                    opacity: 0.9
                });
                const particle = new THREE.Mesh(particleGeometry, material);
                particle.position.set(
                    camera.position.x + (Math.random() - 0.5) * 500,
                    camera.position.y + (Math.random() - 0.5) * 500,
                    camera.position.z + (Math.random() - 0.5) * 500
                );
                particle.userData = {
                    velocity: new THREE.Vector3((Math.random() - 0.5) * 0.03, (Math.random() - 0.5) * 0.03, (Math.random() - 0.5) * 0.03),
                    pulse: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.02
                };
                scene.add(particle);
                particles.push(particle);
            }

            // Create dust particles
            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 600;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() *Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.5,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.015,
                    -0.05,
                    (Math.random() - 0.5) * 0.015
                ))
            };
            dustParticles.push(dust);

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('start-button').addEventListener('click', startExperience);

            if (isMobile) {
                setupGyroscope();
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                document.addEventListener('gesturechange', (e) => e.preventDefault());
                document.addEventListener('gestureend', (e) => e.preventDefault());
            }

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // Gyroscope setup
        function setupGyroscope() {
            if (window.DeviceOrientationEvent) {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', onDeviceOrientation);
                                useGyroscope = true;
                                console.log('Gyroscope permission granted');
                            }
                        })
                        .catch(error => console.error('Error requesting gyroscope permission:', error));
                } else {
                    window.addEventListener('deviceorientation', onDeviceOrientation);
                    useGyroscope = true;
                    console.log('Gyroscope enabled without permission');
                }
            } else {
                console.log('DeviceOrientation API not supported');
            }
        }

        // Handle device orientation
        function onDeviceOrientation(event) {
            if (!initialOrientation) {
                initialOrientation = { alpha: event.alpha, event.beta, gamma };
                return;
            }

            let alpha = THREE.MathUtils.degToRad(event.alpha || 0);
            let beta = THREE.MathUtils.degToRad(event.beta || 0);
            let gamma = THREE.MathUtils.degToRad(event.gamma || 0);

            alpha -= THREE.MathUtils.degToRad(initialOrientation.alpha || 0);
            beta -= THREE.MathUtils.degToRad(initialOrientation.beta || 0);
            gamma -= THREE.MathUtils.degToRad(initialOrientation.gamma || 0);

            const isLandscape = Math.abs(window.orientation) === 90;
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

            const quaternion = new THREE.Quaternion();
            const euler = new THREE.Euler();

            if (isIOS) {
                euler.set(beta, -alpha, gamma, 'YXZ');
            } else {
                euler.set(beta, alpha, -gamma, 'YXZ');
            }

            if (isLandscape) {
                const landscapeAdjust = new THREE.Euler(0, 0, Math.PI / 2);
                const landscapeQuat = new THREE.Quaternion().setFromEuler(landscape);
                quaternion.multiply(landscapeQuat);
            }

            quaternion.setFromEuler(euler);

            if (!isDragging && !isPinching) {
                camera.quaternion.copy(quaternion);
            }

            const eulerCheck = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
            eulerCheck.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, eulerCheck.x));
            camera.quaternion.setFromEuler(eulerCheck);
        }

        // Preload images
        function preloadImages() {
            availableImages.forEach(img => {
                const tempImage = new Image();
                tempImage.src = img.src;
                tempImage.onload = () => console.log(`Preloaded image: ${img.src}`);
                tempImage.onerror = () => console.error(`Failed to preload image: ${img.src}`);
            });
        }

        // Start experience
        function startExperience() {
            document.getElementById('info-screen').style.display = 'none';
            controls.enabled = true;
            isExperienceStarted = true;
            if (!isMobile) {
                controls.lock();
            } else {
                controls.enabled = false;
            }
            const audio = document.getElementById('background-music');
            if (audio.paused) {
                audio.play().catch(error => console.error('Error playing audio:', error));
            }
        }

        // Keyboard controls
        function onKeyDown(event) {
            // Prevent browser shortcuts when experience is active
            if (isExperienceStarted && event.ctrlKey) {
                if (event.code === 'KeyW' || event.code === 'KeyS') {
                    event.preventDefault();
                    console.log(`Blocked Ctrl + ${event.code}`);
                }
            }

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': moveUp = true; break;
                case 'Space': moveDown = true; break;
                case 'ControlLeft': 
                case 'ControlRight': isCtrlPressed = true; break;
                case 'Escape': controls.unlock(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': moveUp = false; break;
                case 'Space': moveDown = false; break;
                case 'ControlLeft': 
                case 'ControlRight': isCtrlPressed = false; break;
            }
        }

        // Touch controls
        function onTouchStart(event) {
            event.preventDefault();
            console.log(`Touch start: ${event.touches.length} fingers`);
            if (event.touches.length === 1) {
                isDragging = true;
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                pinchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            event.stopPropagation();
            console.log(`Touch move: ${event.touches.length} fingers`);
            if (event.touches.length === 1 && isDragging) {
                const deltaX = event.touches[0].clientX - touchStartX;
                const deltaY = event.touches[0].clientY - touchStartY;
                const yaw = -deltaX * 0.003;
                const pitch = -deltaY * 0.003;
                const euler = new THREE.Euler(pitch, yaw, 0, 'YXZ');
                const quaternion = new THREE.Quaternion().setFromEuler(euler);
                camera.quaternion.multiplyQuaternions(quaternion, camera.quaternion);
                const eulerCheck = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
                eulerCheck.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, eulerCheck.x));
                camera.quaternion.setFromEuler(eulerCheck);
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
            } else if (event.touches.length === 2 && isPinching) {
                const dx = event.touches[0].clientX - event.touches[1].clientX;
                const dy = event.touches[0].clientY - event.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const deltaPinch = (distance - pinchStartDistance) * 0.08;
                console.log(`Pinch delta: ${deltaPinch}`);
                const moveSpeed = 0.4;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                camera.position.add(forward.multiplyScalar(deltaPinch * moveSpeed));
                pinchStartDistance = distance;
            }
        }

        function onTouchEnd(event) {
            event.preventDefault();
            console.log('Touch end');
            isPinching = false;
            isDragging = false;
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Spawn text objects
        function spawnTextNearCamera() {
            if (!font || texts.length >= maxTexts) return;
            const text = romanticWords[Math.floor(Math.random() * romanticWords.length)];
            const geometry = new THREE.TextGeometry(text, {
                font: font,
                size: 4.5,
                height: 0.6,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.15,
                bevelSize: 0.1,
                bevelSegments: 3
            });
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                transparent: true
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                camera.position.x + (Math.random() - 0.5) * 400,
                camera.position.y + (Math.random() - 0.5) * 400,
                camera.position.z + (Math.random() - 0.5) * 400
            );
            mesh.userData = {
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.03, -0.06, (Math.random() - 0.5) * 0.03),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(mesh);
            texts.push(mesh);
        }

        // Spawn particles
        function spawnParticleAtCamera() {
            if (particles.length >= maxParticles) return;
            const material = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0xff4d4d : 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const particle = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), material);
            const radius = 120;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            particle.position.copy(camera.position).add(new THREE.Vector3(x, y, z));
            particle.userData = {
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.03, (Math.random() - 0.5) * 0.03, (Math.random() - 0.5) * 0.03),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            };
            scene.add(particle);
            particles.push(particle);
        }

        // Spawn dust
        function spawnDustNearCamera() {
            if (dustParticles.length >= maxDustGroups) return;
            const dustGeometry = new THREE.BufferGeometry();
            const dustVertices = [];
            const dustCount = 600;
            for (let i = 0; i < dustCount; i++) {
                dustVertices.push(
                    camera.position.x + (Math.random() - 0.5) * 1000,
                    camera.position.y + (Math.random() - 0.5) * 1000,
                    camera.position.z + (Math.random() - 0.5) * 1000
                );
            }
            dustGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dustVertices, 3));
            const dustMaterial = new THREE.PointsMaterial({
                color: Math.random() > 0.5 ? 0xffffff : 0xff6666,
                size: 0.5,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/circle.png'),
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const dust = new THREE.Points(dustGeometry, dustMaterial);
            scene.add(dust);
            dust.userData = {
                velocities: Array(dustCount).fill().map(() => new THREE.Vector3(
                    (Math.random() - 0.5) * 0.015,
                    -0.05,
                    (Math.random() - 0.5) * 0.015
                ))
            };
            dustParticles.push(dust);
        }

        // Spawn images
        function spawnImageNearCamera() {
            if (imagePlanes.length >= maxImages || availableImages.length === 0) return;
            const imgElement = availableImages[Math.floor(Math.random() * availableImages.length)];
            const cssObject = new THREE.CSS3DObject(imgElement.cloneNode(true));
            const minDistance = 60, maxDistance = 250;
            const radius = minDistance + Math.random() * (maxDistance - minDistance);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            cssObject.position.copy(camera.position).add(new THREE.Vector3(
                radius * Math.sin(phi) * Math.cos(theta),
                radius * Math.sin(phi) * Math.sin(theta),
                radius * Math.cos(phi)
            ));
            cssObject.lookAt(camera.position);
            const scaleFactor = 0.06;
            cssObject.scale.set(scaleFactor, scaleFactor, scaleFactor);
            cssObject.userData = {
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.015, 0.015, (Math.random() - 0.5) * 0.015),
                pulse: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.005
            };
            scene.add(cssObject);
            imagePlanes.push(cssObject);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Update light
            dynamicLight.position.set(
                10 * Math.sin(time * 0.001),
                10 * Math.cos(time * 0.001),
                10 * Math.sin(time * 0.0005)
            );
            dynamicLight.intensity = 3.0 + Math.sin(time * 0.002) * 0.5;

            // Spawn objects
            const isInitialLoad = time < initialLoadTime + 5000;
            const textSpawnChance = isInitialLoad ? 0.4 : 0.15;
            const dustSpawnChance = isInitialLoad ? 0.8 : 0.4;
            const imageSpawnChance = isInitialLoad ? 0.02 : 0.008;

            if (Math.random() < textSpawnChance && texts.length < maxTexts) spawnTextNearCamera();
            if (((moveForward || moveBackward || moveLeft || moveRight || moveUp || moveDown) && time - lastParticleTime > 10) || Math.random() < 0.2) {
                if (particles.length < maxParticles) {
                    spawnParticleAtCamera();
                    lastParticleTime = time;
                }
            }
            if (Math.random() < dustSpawnChance && dustParticles.length < maxDustGroups) spawnDustNearCamera();
            if (Math.random() < imageSpawnChance && imagePlanes.length < maxImages) spawnImageNearCamera();

            // Update particles
            particles.forEach(particle => {
                particle.position.add(particle.userData.velocity);
                particle.rotation.x += particle.userData.rotationSpeed;
                particle.rotation.y += particle.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + particle.userData.pulse) * 0.2 + 0.8;
                const distance = particle.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1 : Math.max(0, Math.exp(-(distance - clearZone) / 80));
                particle.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || particle.position.y < camera.position.y - maxDistance) {
                    scene.remove(particle);
                    particles = particles.filter(p => p !== particle);
                }
            });

            // Update texts
            texts.forEach(text => {
                text.position.add(text.userData.velocity);
                text.rotation.y += text.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + text.userData.time.pulse);
                const distance = text.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1 : Math.max(0, Math.exp(-(distance - clearZone) / 80));
                text.material.opacity = pulse * fadeFactor;
                if (distance > maxDistance || text.position.y < camera.position.y - maxDistance) {
                    scene.remove(text);
                    texts = texts.filter(p => p !== text);
                }
            });

            // Update dust
            dustParticles = dustParticles.filter(dust => {
                const positions = dust.geometry.attributes.position.array;
                const velocities = dust.userData.velocities;
                let keep = true;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i / 3].x;
                    positions[i + 1] += velocities[i / 3].y;
                    positions[i + 2] += velocities[i / 3].z;
                    const distance = new THREE.Vector3(positions[i]);
                    if (distance <= maxDistance && positions[i + 1] > camera.position.y - maxDistance) {
                        keep = true;
                        const fadeFactor = distance < clearZone ? 1 : Math.max(0, Math.exp(-(distance - clearZone) / 80));
                        dust.material.opacity = 1.0 * fadeFactor;
                    }
                }
                dust.geometry.attributes.position.needsUpdate = true;
                dust.material.needsUpdate = true;
                if (!keep) {
                    scene.remove(dust);
                    return false;
                }
                return true;
            });

            // Update images
            imagePlanes.forEach(image => {
                image.position.add(image.userData.velocity);
                image.lookAt(camera.position);
                image.rotation.y += image.userData.rotationSpeed;
                const pulse = Math.sin(time * 0.001 + image.userData.pulse) * 0.1 + 0.9;
                const distance = image.position.distanceTo(camera.position);
                const fadeFactor = distance < clearZone ? 1 : Math.max(0.5, Math.exp(-(distance - clearZone) / 50));
                image.element.style.opacity = pulse * fadeFactor;
                if (distance > maxDistance || image.position.y > camera.position.y + maxDistance) {
                    scene.remove(image);
                    imagePlanes = imagePlanes.filter(img => img !== image);
                });
            });

            // Update desktop controls
            if (!isMobile) {
                velocity.x *= 0.9;
                velocity.y *= 0.9;
                velocity.z *= 0.9;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.y = Number(moveUp) - Number(moveDown);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400 * delta;
                if (moveUp || moveDown) velocity.y -= direction.y * 400 * delta;

                const speedMultiplier = isCtrlPressed ? 2 : 1;
                controls.moveRight(-velocity.x * delta * speedMultiplier);
                controls.moveForward(-velocity.z * delta * speedMultiplier);
                controls.getObject().position.y += velocity.y * delta * speedMultiplier;
            }

            composer.render();
            cssRenderer.render(scene, camera);
            prevTime = time;
        }

        init();
    </script>
</body>
</html>
